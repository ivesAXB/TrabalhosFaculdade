- Primeiro erro que me deparei foi tentar executar/compilar o arquivo que eu estava editando, sendo que eu não estava nem na pasta
TrabalhosFaculdade.

- Para criar classe: NomeDaClasse NomeDaVariavel = new NomeClasse(FonteDosDados)

- Ao criar a classe Scanner, e criar a variável que vou utilizar para ler (variavel leitor) e adicionar a fonte de onde sairá esses 
FonteDosDados (FonteDosDados) é uma boa prática eu fechar este leitor no final do uso com a função leitor.close(); 

- Uma observação, ao aparecer o Primeiro erro que eu citei, eu tentei rodar com o comando javac .... e criou uma pasta .class, a compilada.

-Descobri também que não tem exponemciação em java então precisei utilizar um método chamado math.pow();

-Math.pow(base, expoente); pode ser utilizado dentro de uma outra variavel quando não precisar guardar ela.

-Ao realizar o exercicio 6 eu me deparei com o problema: 
    if (bool_1 == "sim") {
        for (int i = 0; i < 10; i++) {
           System.out.println(i);
        }
    }
Não estava entrando no if, bool_1 é uma String que o user digita, mas aprendi que para verificar uma condição com uma variável tipo string devo usar:
    if (bool_1.equals("sim")) {
        System.out.println("Entrou no if!");
    }
a função ou método .equals ("");

Pode até misturar isso com o método .trim(); e .equalsIgnoreCase();

-No exercício 7 me deparei com um problema um pouco pior que os anteriores, que foi criar uma array, ao descobrir que utiliza-se o comando: double[] valores = new double[n-1];
para criar uma array, eu entendi que na verdade array é parecido com o objeto. TipoArray[] variavel = new Tipo[tamanho];

-Ler os comentarios no exercicio 7, talvez sejam bem importantes e é melhor para entender por lá.

-Ok cheguei em uma parte que eu tive que recorrer à ajuda da IA, na questão 10 eu sabia que eu precisava usar recursão, eu ja li sobre recursão em um livro, porém
eu não tinha a menor ideia de como eu faria isso, pensei em todos os for possíveis, while e if, mas eu esqueci completamente da existencia de FUNÇÕES.

-Custou para eu entender o que acontecia dentro de uma recursão, em livros parece muito mais fácil, mas eu admito que sem o livro eu não entenderia, tenho certeza, nao da
forma que entendi, concluí que a melhor maneira de aprender isso seria com o livro em uma mão, o código em outra, e um chatIA na terceira mão (como vai conseguir ela é com você).

-Ao realizar o exercício 11 eu notei que por mais que eu entenda como funciona o for, ainda causa um nó bem grande na minha cabeça, então resolvi deixar uma logica aqui:
System.out.println("Quantos números irá digitar? ");   
        int n = leitor.nextInt(); ---------------------------------------------------------------------->|ele vai ler o indice e atribuir à uma variavel
        System.out.println("Digite uma sequencia de números"); ----------------------------------------->|ele vai pedir os números, mas eu só vou ler dentro do for.
        int[] inteiros = new int[n]; ------------------------------------------------------------------->|me engano achando que ele vai ler aqui, mas aqui é para criar o objeto.

        int maior_numero = 0; -------------------------------------------------------------------------->|só para exercicio de buscar maior número.

        for (int i = 0; i < n; i++){ ------------------------------------------------------------------->|aqui a brincadeira começa, aqui o i precisa entrar como índice...
            inteiros[i] = leitor.nextInt(); ------------------------------------------------------------>|se eu colocar ele como i = 1 ele vai ler o indice 0 como 1 e isso vai 
            if(maior_numero < inteiros[i]){ -------------------------------------------------------------|causar um certo conflito pq ele vai começar a ler do incide 1, e vai
                maior_numero = inteiros[i]; -------------------------------------------------------------|até o índice 6, que não existe, ou seja ele vai ler 1 a menos e depois
            }  ------------------------------------------------------------------------------------------|tentar ler um a mais que não existe.
            System.out.printf("Pegando o número %d e colocando no indice %d.\n",inteiros[i], i);
        }
(O código não funciona para numeros negativos, para funcionar apenas com números negativos basta apenas atribuir o valor maior para o primeiro numero da array)

-Perdendo os cabelos aprendendo a fazer um método de ordenação crescentes de números com recursão (exercicio 12).

-Segundo dia no exercício 12;
int meio = (arrayParaOrdenar.length/2); ----------------------------------> essa foi uma definição importante, pois aqui eu digo quanto de tamanho vai ter cada uma metade
        int[] metadeesquerda = new int[meio]; ----------------------------> a parte do meio esquerda pode ter 2,5 lenght que arredondaria para 3
        int[] metadedireita = new int[(arrayParaOrdenar.length - meio)]; ---> automaticamente o meio direito teria 2 (5-3)
    
if (arrayParaOrdenar.length <= 1){ ---------------------------------------> Até aqui estava tudo bem, entendi que se tiver 1 de tamanho vai retornar só ele,
                return arrayParaOrdenar; ---------------------------------> em seguida no else (se nao tiver só 1 de tamanho) vou fazer um for para atribuir
            } else { -----------------------------------------------------> informações na parte esquerda, e outro para atribuir informações na parte direita
                for(int i = 0; i < meio; i++){ ---------------------------> sendo a esquerda começando no indice 0 e indo até o indice 'meio'
                    metadeesquerda[i] = arrayParaOrdenar[i]; -------------> e a parte direita eu começo meu incide no 'meio' e vou até o tamanho total da array.
                } --------------------------------------------------------> 
                for(int i = meio; i < arrayParaOrdenar.length; i++){ -----> Mas não funcionou.
                    metadedireita[i - meio] = arrayParaOrdenar[i]; --------------> <- nesta linha repare que o arrayParaOrdenar nao pode ter indice [i] pois ja usei eles acima.
                } --------------------------------------------------------> talvez se eu utilizar metadedireita[i-meio] (?vou testar)

- Ok funcionou perfeitamente e me orgulho de ter entendido e achado uma saída para isso, se eu utilizasse metadedireita[meio] eu iria atribuir valor à um indice além dos iniciais,
ou seja, eu deixaria o inicio da array metadedireita vazia, estourando no final pois o for continuaria tentando colocar valores nos indices que nao existe no tamanho da array.
exemplo: 
utilizando 12 valores: 
metadeesquerda[6] e inicia em 0 até 6
metadedireita[12-6] e inicia em 6 (meio) = metadedireita[6] com o loop iniciando no indice meio (6)...
da forma que fiz ele inicia sim no indice 6, mas eu retiro o valor 'meio' do indice metadedireita, ou seja metadedireita[6-6=0], segundo tic do loop seria: metadedireita[7-6=1]

- Com isso eu acredito que pulo uma etapa de aprendizagem que seria utilizar mais de uma variável no parametro do for, onde eu usaria j = 0 para definir o indice do metadedireita
e i = meio para definir o indice do arrayParaOrdenar.

-O exercicio 14 também foi bem dificil de fazer, eu tinha toda a lógica na mente mas nao conseguia colocar em pratica, eu sabia que se eu usasse:

for(int j = 0; j < n; j++){                                              | Eu teria o seguinte problema: Utilizando 1 em todas as casas
            for(int i = j + 1; i < n; i++){                              | array[0] == array[1] (1,1) repetido = 1 | Dessa forma eu teria 10 repetidos, tendo apenas 5
                if((array_para_analise[j] == array_para_analise[i])){    | array[0] == array[2] (1,1) repetido = 2 | valores na array, concluí que, ao perceber que se o elemento
                    repetidos++;                                         | array[0] == array[3] (1,1) repetido = 3 | da array da esqueda já tivesse um valor igual, eu deveria
                }                                                        | array[0] == array[4] (1,1) repetido = 4 | adicionar mais 1 aos repetidos, e parar de comparar ele com
            }                                                            | array[1] == array[2] (1,1) repetido = 5 | outros e deixar esse trabalho para o próximo elemento
        }                                                                | array[1] == array[3] (1,1) repetido = 6 | da array, então coloquei um break; se o repetidos ganhasse
                                                                         | array[1] == array[4] (1,1) repetido = 7 | mais um valor, dessa forma eu estou limitando a contadem de
                                                                         | array[2] == array[3] (1,1) repetido = 8 | repetidos à 1 por elemento da array.
                                                                         | array[2] == array[4] (1,1) repetido = 9 |
                                                                         | array[3] == array[4] (1,1) repetido = 10|

-Excluí o exercicio 14 e comecei do zero.

-Dessa vez vou tentar analisar os numeros ao mesmo tempo que eu crio o array sem repetições.

-
